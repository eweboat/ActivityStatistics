Notes on programme structure
----------------------------

The paradigm that I have used to support the brief is similar to a passive implementation of the MVC pattern. A Report object corresponding to a view on the model that is represented by DataStore. This could be extended into say the Model-View-Presenter pattern where a presenter could read and further format the output generated by a given report.

Given that the assignment doesn't many guiding constraints on the programme I have chosen to implement only as much as is needed for the functionality as suggested by the brief. To this end I left the interchange data types in a fairly open format; if I were to iterate further on this project I would look at repacing the typedef stl containers with class objects that encapulate required containers. Not least amount the reasons for doing this would be that copy overhead that is placed on standard containers by these data rich internals which could be replace to store a pointer to a wrapping object.

The intention behind the report class is that new reports can be created without editing any of the existing code in support of the open/closed principle. The public interface of the report family of classes is fixed by the base class and specialisation takes place through private virtual member functions. 

I have implemented the DataStore class as a singleton so that it can be accessed without creating undue coupling. Conversely it could be passed to objects as required. This decision would need to make in the broader context of requirments.

Discussion of points raised in the brief
----------------------------------------


 - we'd also like a sketch (but don't implement) of how to implement statistics for "num" most common "action sequences" and their counts (see [1]) per Web site. I.e., for each site find the most frequent sequence of actions. Order sequences by their frequency (most frequent first). Order sequences of equal frequency by their length (number of actions in a sequence, longest first). 

* how to be flexible about data numbers and types
In order to support flexible data types I would make a template around the DataStore class. I have constructed an example of such a class at the end of this file (note that my example also includes a data access policy template).

* how to support a wider range of statistics
As touched on above additional statistics can be easily supported by publically derriving from the Report base class. This would be non-intrusive to the rest of the code base. If the new class derrived from Report required a data aggregation that is not offered by DataStore there are two options 1.) enhance the DataStore data model 2.) Pull the set of RawData objects from DataStore and compose these data into a model that the report can access.

* how to support getting data from a different source
Again there would be options here. If individual reports needed to access data from a different source then instead of accessing the DataStore singleton a report could simpley read data from another object. Access credentials could be passed in at contruction or could access could be via another, different singleton.
The other option would be to switch the access method used by DataStore itself e.g. read from a database instead of processing flat files. In this case I would inject an access policy into DataStore by deriving from a templated policy base class. Please see the example I have constructed below.

* how to support output in different formats, or use the statistics in other ways
For a given concrete Report class (which represent statistics in this context) I would suggest taking the standard string output generated by the Report object and passinging to to a class with the responsibility of alternately formatting these data, that is use the Model-View-Presenter pattern. The Presenter class might format the data to be colour coded, for example.

* how to support processing "real time" data where actions come in one after another and the statistics need to be updated
 To run against live data there will be a need to record time stamps on incomming data. Reports will need to store the timestamp of their most recent data snapshot and likely some state. Subsequent report runs might then take only the delta data. For example the mean actions report might store how many records were used to generate the mean so that new data can be augmented without biasing the weights. One method to so this would be to re-inflate the mean join the new data and recalculate the mean but I suspect that there would a better method to achieve this so as to avoid hardware limitations.

Re-expression of DataStore for flexible data type storage and alternate data access methods.
The policy based DataStore class can be extended with the addition of alternate policies.

// access policies
template <class T> struct FileAccess
{
   std::vector<T> ReadData() { /* read data from file */ }
};
template <class T> struct DatabaseAccess
{
   std::vector<T> ReadData() { /* read data from database */ }
};

// revised DataStore
template
<
   class T,
   template <class> class AccessPolicy
>
class DataStore : public AccessPolicy<T>, public AdditionalPolicy ...
{
   //...
	void ReadData()
	{
		m_data = AccessPolicy<T>::ReadData();
	}
private:
   std::vector<T> m_data;
};

typedef DataStore<RawData, FileAccess> DataStoreFile;
typedef DataStore<RawData, DatabaseAccess> DataStoreDatabase;



