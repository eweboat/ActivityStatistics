Notes on programme structure
----------------------------

The paradigm that I have used to support the brief is similar to a passive implementation of the MVC pattern. A Report object corresponding to a view on the model that is represented by DataStore. This could be extended into say the Model-View-Presenter pattern where a presenter could read and further format the output generated by a given report.

Given that the assignment doesn't many guiding constraints on the programme I have chosen to implement only as much as is needed for the functionality as suggested by the brief. To this end I left the interchange data types in a fairly open format; if I were to iterate further on this project I would look at replacing the typedef stl containers with class objects that encapsulate required containers. Not least amount the reasons for doing this would be that copy overhead that is placed on standard containers by these data rich internals which could be replace to store a pointer to a wrapping object.

The intention behind the report class is that new reports can be created without editing any of the existing code in support of the open/closed principle. The public interface of the report family of classes is fixed by the base class and specialisation takes place through private virtual member functions. 

I have implemented the DataStore class as a singleton so that it can be accessed without creating undue coupling. Conversely it could be passed to objects as required. This decision would need to make in the broader context of requirements.

A note on usage of stl containers
---------------------------------

In practice the only items that I would normally put into stl containers are plain old data types and pointers as stl contains will frequently perform copy/move operation on their internals. The implementation used in my code would be replaced with containers that hold pointers to class objects. 
For stl strings I would seek to store them once in a string dictionary and elsewhere store a handle which would act as a key to the string dictionary. 

Discussion of points raised in the brief
----------------------------------------

* how to implement statistics for "num" most common "action sequences" and their counts 
Assumption: that for each session only one website is accessed. This is true in the data but may not be true in general.
My initial though here is that generating this data set would quite likely involve a good deal of processing and so I would consider using lazy evaluation - after all we may never actually access the data!
My naïve method would be as follows. For each new record maintain a standard map of each session id to a vector of action in time order i.e. std::map< Session*, std::vector<Action*>> (we'd need to store website for this session too, of course). To generate the report each vector of actions would to be split into all possible action sequences. A vector of N actions would generate SUM(i) over the range i=1 to N i.e. a lot! The painful step would then be to seek matches across the whole set! 
I would approach this by writing code to support a functionally correct (if naïve) algorithm and then to seek areas of improvement… alternatively said: functionality and clarity first, optimisation later.

* how to be flexible about data numbers and types
In order to support flexible data types I would make a template around the DataStore class. I have constructed an example of such a class at the end of this file (note that my example also includes a data access policy template).

* how to support a wider range of statistics
As touched on above additional statistics can be easily supported by publically deriving from the Report base class. This would be non-intrusive to the rest of the code base. If the new class derived from Report required a data aggregation that is not offered by DataStore there are two options 1.) enhance the DataStore data model 2.) Pull the set of RawData objects from DataStore and compose these data into a model that the report can access.

* how to support getting data from a different source
Again there would be options here. If individual reports needed to access data from a different source then instead of accessing the DataStore singleton a report could simply read data from another object. Access credentials could be passed in at construction or could access could be via another, different singleton.
The other option would be to switch the access method used by DataStore itself e.g. read from a database instead of processing flat files. In this case I would inject an access policy into DataStore by deriving from a templated policy base class. Please see the example I have constructed below.

* how to support output in different formats, or use the statistics in other ways
For a given concrete Report class (which represent statistics in this context) I would suggest taking the standard string output generated by the Report object and passing it to a class with the responsibility of alternately formatting these data, that is use the Model-View-Presenter pattern. The Presenter class might format the data to be colour coded, for example.

* how to support processing "real time" data where actions come in one after another and the statistics need to be updated
 To run against live data there will be a need to record time stamps on incoming data. Reports will need to store the timestamp of their most recent data snapshot and likely some state. Subsequent report runs might then take only the delta data. For example the mean actions report might store how many records were used to generate the mean so that new data can be augmented without biasing the weights. One method to so this would be to re-inflate the mean join the new data and recalculate the mean but I suspect that there would a better method to achieve this so as to avoid hardware limitations.

Templated policy based version of DataStore
-------------------------------------------

Re-expression of DataStore for flexible data type storage and alternate data access methods.
The policy based DataStore class can be extended with the addition of alternate policies.

// access policies
template <class T> struct FileAccess
{
   std::vector<T> ReadData() { /* read data from file */ }
};
template <class T> struct DatabaseAccess
{
   std::vector<T> ReadData() { /* read data from database */ }
};

// revised DataStore
template
<
   class T,
   template <class> class AccessPolicy
>
class DataStore2 : public AccessPolicy<T>, public AdditionalPolicy ...
{
   //...
	void ReadData()
	{
		m_data = AccessPolicy<T>::ReadData();
	}
private:
   std::vector<T> m_data;
};

typedef DataStore2<RawData, FileAccess> DataStoreFile;
typedef DataStore2<RawData, DatabaseAccess> DataStoreDatabase;

